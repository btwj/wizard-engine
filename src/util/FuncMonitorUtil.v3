private class FuncWithLoopEnterProbe(probe: Probe, frameAccessors: ListStack<FrameAccessor>) extends Probe {
	def fire(func: WasmFunction, pc: int, frame: TargetFrame) -> Resumption {
		var curAccessor = frame.getFrameAccessor();
		if (!frameAccessors.empty() && curAccessor == frameAccessors.peek())
			return Resumption.Continue;
		frameAccessors.push(curAccessor);
		if (probe != null)
			return probe.fire(func, pc, frame);
		return Resumption.Continue;
	}
}

private class FuncWithLoopExitProbe(probe: Probe, frameAccessors: ListStack<FrameAccessor>) extends Probe {
	def fire(func: WasmFunction, pc: int, frame: TargetFrame) -> Resumption {
		frameAccessors.pop();
		if (probe != null)
			return probe.fire(func, pc, frame);
		return Resumption.Continue;
	}
}

component FuncMonitorUtil {
	def insertProbeAtFuncEnterExit(module: Module, func: FuncDecl, enterProbe: Probe, exitProbe: Probe) -> (Probe, Probe) {
		var it = BytecodeIterator.new();
		var bi = it.reset(func);

		var startsWithLoop = false;
		var frameAccessors: ListStack<FrameAccessor>;
		var newEnterProbe = enterProbe;
		if (bi.current() == Opcode.LOOP) {
			startsWithLoop = true;
			frameAccessors = ListStack<FrameAccessor>.new();
			newEnterProbe = FuncWithLoopEnterProbe.new(enterProbe, frameAccessors);
		}
		if (newEnterProbe != null) module.insertProbeAt(func.func_index, bi.pc, newEnterProbe);

		var newExitProbe = exitProbe;
		if (startsWithLoop) newExitProbe = FuncWithLoopExitProbe.new(exitProbe, frameAccessors);

		for (bi = it.reset(func); bi.more(); bi.next()) {
			var op = bi.current();
			match (op) {
				RETURN => ;
				END => if (bi.pc + 1 < bi.func.cur_bytecode.length) continue;
				_ => continue;
			}

			if (newExitProbe != null) module.insertProbeAt(func.func_index, bi.pc, newExitProbe);
		}

		return (newEnterProbe, newExitProbe);
	}

	def removeProbeAtFuncEnterExit(module: Module, func: FuncDecl, enterProbe: Probe, exitProbe: Probe) {
		var it = BytecodeIterator.new();
		var bi = it.reset(func);
		bi.current();
		if (enterProbe != null) module.removeProbeAt(func.func_index, bi.pc, enterProbe);

		for (bi = it.reset(func); bi.more(); bi.next()) {
			var op = bi.current();
			match (op) {
				RETURN => ;
				END => if (bi.pc + 1 < bi.func.cur_bytecode.length) continue;
				_ => continue;
			}

			if (exitProbe != null) module.removeProbeAt(func.func_index, bi.pc, exitProbe);
		}
	}
}
