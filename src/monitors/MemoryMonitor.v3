// Copyright 2023 Wizard Authors. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// Implements a simple memory monitor with two modes:
// 1. Traces all memory instructions
// 2. Records memory reads/writes on a page granularity and reports at end of execution
class MemoryMonitor extends Monitor {
	var pageReads: Array<Vector<u64>>;
	var pageWrites: Array<Vector<u64>>;
	var pageLevel = false;
	
	def configure(args: string) -> string {
		if (Strings.equal(args, "pages")) pageLevel = true;
		return null;
	}
	def onParse(module: Module) {
		var mm = ModuleMonitor.new(module);
		if (!pageLevel) {
			mm.beforeMemRead(traceBeforeMemRead);
			mm.beforeMemWrite(traceBeforeMemWrite);
			mm.beforeMemGrow(traceBeforeMemGrow);
		} else {
			mm.beforeMemRead(recordPageRead);
			mm.beforeMemWrite(recordPageWrite);
			mm.beforeMemGrow(recordMemGrow);
		}
	}
	def onInstantiate(instance: Instance) {
		pageReads = Array.new(instance.memories.length);
		pageWrites = Array.new(instance.memories.length);
		for (i < instance.memories.length) {
			var memory = instance.memories[i];
			pageReads[i] = Vector.new();
			pageReads[i].putn(0, int.!(memory.size()));
			pageWrites[i] = Vector.new();
			pageWrites[i].putn(0, int.!(memory.size()));
		}
	}
	def onFinish(instance: Instance) {
		if (!pageLevel) return;
		for (i < instance.memories.length) {
			Trace.OUT.puts("mem");
			putMemIndex(i);
			Trace.OUT.put1(": pages=%d", pageReads[i].length).outln();
			Trace.OUT.puts("  R: ");
			for (j < pageReads[i].length) {
				if (j > 0) Trace.OUT.csp();
				Trace.OUT.putd(pageReads[i][j]);
			}
			Trace.OUT.outln();
			Trace.OUT.puts("  W: ");
			for (j < pageWrites[i].length) {
				if (j > 0) Trace.OUT.csp();
				Trace.OUT.putd(pageWrites[i][j]);
			}
			Trace.OUT.outln();
		}
	}

	private def putMemIndex(index: int) {
		if (index != 0) Trace.OUT.put1("[%d]", index);
	}
	private def traceBeforeMemRead(dynamicLoc: DynamicLoc, mem: Memory, index: u64, size: u64) -> Resumption {
		Trace.OUT.puts("read  mem");
		putMemIndex(mem.decl.memory_index);
		Trace.OUT.put1(" @ 0x%x", index);
		Trace.OUT.put1("[size=%d]", size).outln();
		return Resumption.Continue;
	}
	private def traceBeforeMemWrite(dynamicLoc: DynamicLoc, mem: Memory, index: u64, size: u64) -> Resumption {
		Trace.OUT.puts("write mem");
		putMemIndex(mem.decl.memory_index);
		Trace.OUT.put1(" @ 0x%x", index);
		Trace.OUT.put1("[size=%d]", size).outln();
		return Resumption.Continue;
	}
	private def traceBeforeMemGrow(dynamicLoc: DynamicLoc, mem: Memory, pages: u32) -> Resumption {
		Trace.OUT.puts("grow  mem");
		putMemIndex(mem.decl.memory_index);
		Trace.OUT.put1(" +%d", pages).outln();
		return Resumption.Continue;
	}

	private def recordPageRead(dynamicLoc: DynamicLoc, mem: Memory, index: u64, size: u64) -> Resumption {
		var pageIndex: int = int.!(index / PAGE_SIZE);
		pageReads[mem.decl.memory_index][pageIndex]++;
		//TODO: if read crosses multiple pages
		return Resumption.Continue;
	}
	private def recordPageWrite(dynamicLoc: DynamicLoc, mem: Memory, index: u64, size: u64) -> Resumption {
		var pageIndex: int = int.!(index / PAGE_SIZE);
		pageWrites[mem.decl.memory_index][pageIndex]++;
		return Resumption.Continue;
	}
	private def recordMemGrow(dynamicLoc: DynamicLoc, mem: Memory, pages: u32) -> Resumption {
		var index = mem.decl.memory_index;
		pageReads[index].putn(0, int.!(pages));
		pageWrites[index].putn(0, int.!(pages));
		return Resumption.Continue;
	}
}
def PAGE_SIZE = 65536u;