// Copyright 2023 Wizard Authors. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// Implements a simple monitor that probes memory accesses within a certain range
class MemoryMonitor extends Monitor {
    var range: (u64, u64);
    var loads: Array<int>;
    var stores: Array<int>;

    // format: --monitors=memory{0,4} reports loads and stores to bytes 0-3
    // memory range is in hex
	def configure(args: string) -> string {
		Trace.OUT.puts("done").outln();
        var parseResult = Ints.parseHex(args, 0);
        var start = parseResult.1;
        var end = Ints.parseHex(args, parseResult.0 + 1).1;
        range = (u64.!(start), u64.!(end));
        var length = int.!(range.1 - range.0);

        loads = Array<int>.new(length);
        stores = Array<int>.new(length);
		return null;
	}
    def onParse(module: Module) {
		var mm = ModuleMonitor.new(module);
		mm.beforeMemAccessInRange(range.0, range.1 - range.0, hit(_, _, true), hit(_, _, false));
    }
    def renderRow(rowStart: u64, array: Array<int>) {
        for (j < 8) {
            var cur = rowStart + u64.!(j);
            if (j > 0) Trace.OUT.putc(' ');

            if (cur < range.0 || cur >= range.1) {
                Trace.OUT.puts(TermColors.DARKGRAY);
                Trace.OUT.puts("?");
                Trace.OUT.puts(TermColors.DEFAULT);
            } else {
                Trace.OUT.put1("%d", array[cur - range.0]);
            }
        }
    }
    def onFinish(i: Instance) {
        for (rowStart = range.0 - (range.0 % 8); rowStart < range.1; rowStart += 8) {
            Trace.OUT.puts(TermColors.CYAN);
            Trace.OUT.put1("[%x] ", rowStart);
            Trace.OUT.puts(TermColors.DEFAULT);

            renderRow(rowStart, loads);
            var length = Trace.OUT.length;
            Trace.OUT.pad(' ', length + 5);
            renderRow(rowStart, stores);
            Trace.OUT.outln();
        }
	}

    private def hit(loc: DynamicLoc, memRange: MemRange, isLoad: bool) -> Resumption {
        // TODO: make more efficient by storing deltas instead
        // +1 at address and -1 at address + size
        for (i < memRange.size) {
            var newAddress = memRange.index + i;
            if (newAddress >= range.0 && newAddress < range.1) {
                var index = newAddress - range.0;
                if (isLoad) {
                    loads[index]++;
                } else {
                    stores[index]++;
                }
            }       
        }
		return Resumption.Continue;
    }
}