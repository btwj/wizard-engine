// Copyright 2022 Ben L. Titzer. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// A monitor provides visibility into the execution of Wasm program by instrumenting code
// and/or events that occur while it is running, such as by tracing or collecting statistics
// that are reported upon program finish.
class Monitor {
	// Configure the monitor based on additional arguments supplied on the command line.
	// If any syntax errors are detected in the arguments, this method should return a
	// non-null message to be reported to the user.
	def configure(args: string) -> string {
		return null;
	}
	// Called by the engine after a module is successfully parsed. A monitor may insert
	// instrumentation into the module that will be applied to all instances of the module.
	def onParse(m: Module) {
	}
	// Called by the engine during instantiation when a binding is supplied for an import
	// to a module. A monitor may interpose on the binding (e.g. by wrapping an imported
	// call).
	def onBind(m: Module, d: Decl, e: Exportable) -> Exportable {
		return e;
	}
	// Called by the engine after a module is successfully instantiated. A monitor may
	// insert instrumentation specific to the instance, e.g. on the exports.
	def onInstantiate(i: Instance) {
	}
		// Called by the engine before an instance is started.
	def onStart(f: Function) {
	}
	// Called by the engine before the main method, if any, is called.
	def onMain(f: Function, args: Array<Value>) {
	}
	// Called by the engine after the instance has finished executing, e.g. to print
	// a report.
	def onFinish(i: Instance) {
	}
	// Called by the engine on process exit.
	def onExit(code: int) {
	}
}

type MemRange(index: u64, size: u64) #unboxed;

class ModuleMonitor(module: Module) {
	def beforeStart(f: DynamicLoc -> Resumption) {
	}
	def beforeMain(f: DynamicLoc -> Resumption) {
	}

	// Attach a callback when memory is read (load)
	def beforeMemRead(f: (DynamicLoc, MemRange) -> Resumption) {
		beforeMemOp(f, null, null);
	}
	// Attach a callback when memory is written (store)
	def beforeMemWrite(f: (DynamicLoc, MemRange) -> Resumption) {
		beforeMemOp(null, f, null);
	}
	// Attach callback when memory is accessed (load/store)
	def beforeMemAccess(
		loadFn: (DynamicLoc, MemRange) -> Resumption,
		storeFn: (DynamicLoc, MemRange) -> Resumption
	) {
		beforeMemOp(loadFn, storeFn, null);
	}
	// Attach callback when memory is grown
	def beforeMemGrow(f: (DynamicLoc, u32) -> Resumption) {
		beforeMemOp(null, null, f);
	}
	private def beforeMemOp(
		loadFn: (DynamicLoc, MemRange) -> Resumption,
		storeFn: (DynamicLoc, MemRange) -> Resumption,
		growFn: (DynamicLoc, u32) -> Resumption
	) {
		var it = BytecodeIterator.new();
		var visitor = MemoryVisitor.new(module, loadFn, storeFn, growFn);
		visitor.bi = it;
		
		for (i < module.functions.length) {
			var func = module.functions[i];
			if (MonitorUtil.isImport(module, func)) continue;
			for (bi = it.reset(func); bi.more(); bi.next()) {
				bi.dispatch(visitor);
			}
		}
	}

	// Attach a callback when a memory is read within a specified range
	// In the future, use hardware watchpoints to detect for this
	def beforeMemReadInRange(start: u64, size: u64, f: (DynamicLoc, MemRange) -> Resumption) {
		beforeMemRead(callbackInRange(start, size, f, _, _));
	}
	// Attach a callback when a memory is read within a specified range
	def beforeMemWriteInRange(start: u64, size: u64, f: (DynamicLoc, MemRange) -> Resumption) {
		beforeMemWrite(callbackInRange(start, size, f, _, _));
	}
	// Attach a callback when a memory is accessed within a specified range
	def beforeMemAccessInRange(start: u64, size: u64, loadFn: (DynamicLoc, MemRange) -> Resumption, storeFn: (DynamicLoc, MemRange) -> Resumption) {
		beforeMemAccess(callbackInRange(start, size, loadFn, _, _), callbackInRange(start, size, storeFn, _, _));
	}
	private def callbackInRange(start: u64, size: u64, f: (DynamicLoc, MemRange) -> Resumption, loc: DynamicLoc, memRange: MemRange) -> Resumption {
		if (memRange.index <= start + size && start <= memRange.index + memRange.size) {
			return f(loc, memRange);
		} else {
			return Resumption.Continue;
		}
	}

	// Attach a callback that is called when func (non-import) is called
	def beforeFuncCall(func: FuncDecl, f: DynamicLoc -> Resumption) {
		if (func.imp != null) return;
		beforeFuncCallAndReturn(func, f, null);
	}
	// Attach a callback that is called when func (non-import) returns
	def beforeFuncReturn(func: FuncDecl, f: DynamicLoc -> Resumption) {
		if (func.imp != null) return;
		beforeFuncCallAndReturn(func, null, f);
	}
	// Attach callbacks that are called when a func is called or returns
	def beforeFuncCallAndReturn(func: FuncDecl, callFn: DynamicLoc -> Resumption, retFn: DynamicLoc -> Resumption) {
		var it = BytecodeIterator.new();
		var bi = it.reset(func);

		var startsWithLoop = false;
		var frameAccessors: ListStack<FrameAccessor>;
		if (bi.current() == Opcode.LOOP) {
			startsWithLoop = true;
			frameAccessors = ListStack<FrameAccessor>.new();
			module.insertProbeAt(func.func_index, bi.pc, FuncWithLoopEnterProbe.new(frameAccessors, callFn));
		} else if (callFn != null) {
			module.insertProbeAt(func.func_index, bi.pc, CallbackProbe.new(callFn));
		}

		for (bi = it.reset(func); bi.more(); bi.next()) {
			var op = bi.current();
			match (op) {
				RETURN => ;
				END => if (bi.pc + 1 < bi.func.cur_bytecode.length) continue;
				_ => continue;
			}

			if (startsWithLoop) {
				module.insertProbeAt(func.func_index, bi.pc, FuncWithLoopExitProbe.new(frameAccessors, retFn));
			} else if (retFn != null) {
				module.insertProbeAt(func.func_index, bi.pc, CallbackProbe.new(retFn));
			}
		}
	}

	// Attach a callback to an instruction
	def beforeInstr(func: FuncDecl, pc: int, f: DynamicLoc -> Resumption) {
		module.insertProbeAt(func.func_index, pc, CallbackProbe.new(f));
	}
	def afterInstr(func: FuncDecl, pc: int, f: DynamicLoc -> Resumption) {
		// TODO
	}

	// Attach a callback to any non-import function call
	def beforeCall(f: DynamicLoc -> Resumption) {
		forEachFunc(MonitorUtil.isNotImport, beforeFuncCall(_, f));
	}
	// Attach a callback to any non-import function return
	def beforeReturn(f: DynamicLoc -> Resumption) {
		forEachFunc(MonitorUtil.isNotImport, beforeFuncReturn(_, f));
	}
	// Attach a callback to any non-import function call or return
	def beforeCallAndReturn(callFn: DynamicLoc -> Resumption, retFn: DynamicLoc -> Resumption) {
		forEachFunc(MonitorUtil.isNotImport, beforeFuncCallAndReturn(_, callFn, retFn));
	}

	// Helpers

	// call f(funcDecl) if filter(module, funcDecl) is true
	def forEachFunc(filter: (Module, FuncDecl) -> bool, f: FuncDecl -> void) {
		for (i < module.functions.length) {
			var func = module.functions[i];
			if (!filter(module, func)) continue;
			f(func);
		}
	}
}

component MonitorUtil {
	def isImport(module: Module, func: FuncDecl) -> bool {
		return func.imp != null;
	}
	def isNotImport(module: Module, func: FuncDecl) -> bool {
		return func.imp == null;
	}
}

private class FuncWithLoopEnterProbe(
	frameAccessors: ListStack<FrameAccessor>,
	f: DynamicLoc -> Resumption
) extends Probe {
	def fire(func: WasmFunction, pc: int, frame: TargetFrame) -> Resumption {
		var curAccessor = frame.getFrameAccessor();
		if (!frameAccessors.empty() && curAccessor == frameAccessors.peek())
			return Resumption.Continue;
		frameAccessors.push(curAccessor);
		if (f != null)
			return f(DynamicLoc(func, pc, frame));
		return Resumption.Continue;
	}
}
private class FuncWithLoopExitProbe(
	frameAccessors: ListStack<FrameAccessor>,
	f: DynamicLoc -> Resumption
) extends Probe {
	def fire(func: WasmFunction, pc: int, frame: TargetFrame) -> Resumption {
		frameAccessors.pop();
		if (f != null)
			return f(DynamicLoc(func, pc, frame));
		return Resumption.Continue;
	}
}

private class MemoryVisitor(
	module: Module,
	loadFn: (DynamicLoc, MemRange) -> Resumption,
	storeFn: (DynamicLoc, MemRange) -> Resumption,
	growFn: (DynamicLoc, u32) -> Resumption
) extends BytecodeVisitor {
	var bi: BytecodeIterator;

	def visitLoad(op: Opcode, imm: MemArg) {
		if (loadFn == null) return;
		var size: u64;
		match (op) {
			// TODO: V128, ATOMIC ops
			I32_LOAD8_S, I32_LOAD8_U, I64_LOAD8_S, I64_LOAD8_U => size = 1;
            I32_LOAD16_S, I32_LOAD16_U, I64_LOAD16_S, I64_LOAD16_U => size = 2;
            I32_LOAD, I64_LOAD32_S, I64_LOAD32_U => size = 4;
            I64_LOAD, F64_LOAD => size = 8;
			_ => size = 0;
		}
		module.insertProbeAt(bi.func.func_index, bi.pc, MemoryAccessProbe.new(imm, size, loadFn));
	}
	def visitStore(op: Opcode, imm: MemArg) {
		if (storeFn == null) return;
		var size: u64;
        match (op) {
            // TODO: V128, ATOMIC ops
            I32_STORE8, I64_STORE8 => size = 1;
            I32_STORE16, I64_STORE16 => size = 2;
            I32_STORE, I64_STORE32, F32_STORE => size = 4;
            I64_STORE, F64_STORE => size = 8;
            _ => size = 0;
        }
        module.insertProbeAt(bi.func.func_index, bi.pc, MemoryAccessProbe.new(imm, size, storeFn));
	}
	def visit_MEMORY_GROW(memory_index: u31) {
		module.insertProbeAt(bi.func.func_index, bi.pc, MemoryGrowProbe.new(growFn));
	}
}
private class MemoryAccessProbe(
	imm: MemArg, size: u64,
	f: (DynamicLoc, MemRange) -> Resumption
) extends Probe {
	def fire(func: WasmFunction, pc: int, frame: TargetFrame) -> Resumption {
        var accessor = frame.getFrameAccessor();
        var address: u64 = u64.!(Values.v_i(accessor.getOperand(0)));
        address += imm.offset;

		return f(DynamicLoc(func, pc, frame), MemRange(address, size));
    }
}
private class MemoryGrowProbe(f: (DynamicLoc, u32) -> Resumption) extends Probe {
	def fire(func: WasmFunction, pc: int, frame: TargetFrame) -> Resumption {
		var accessor = frame.getFrameAccessor();
		var pages = u32.!(Values.v_i(accessor.getOperand(0)));
		return f(DynamicLoc(func, pc, frame), pages);
	}
}