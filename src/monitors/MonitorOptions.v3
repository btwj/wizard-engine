// Copyright 2022 Ben L. Titzer. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

enum MonitorOption(op: string, argsUsage: string, monitor: Monitor) {
	loops("loops", "{code}", LoopMonitor.new()),
	coverage("coverage", "{code[=instr]}", CoverageMonitor.new()),
	calls("calls", "{code[=<function pattern*>]}", CallsMonitor.new()),
	branches("branches", "{code}", BranchMonitor.new()),
	profile("profile", "{depth=<num>|calls=<function pattern*>}", ProfileMonitor.new()),
	hotness("hotness", "{code}", HotnessMonitor.new()),
	globals("globals", "", GlobalsMonitor.new()),
	memory("memory", "", MemoryMonitor.new()),
	debug("debug", "", DebugMonitor.new())
}

// Monitors used for testing
enum MonitorOptionTest(op: string, monitor: Monitor) {
	postInstr("_postInstr", PostInstructionTestTracer.new()),
	hostCall("_hostCall", HostCallTestTracer.new()),
	globalHotness("_globalHotness", GlobalHotnessMonitor.new()),
	globalBranch("_globalBranches", GlobalBranchMonitor.new())
}

// Parses and updates monitor options based on arguments.
component MonitorOptions {
	private var monitors = Vector<Monitor>.new();

	new () {
		for (option in MonitorOption) {
			MonitorRegistry.register(option.op, option.monitor);
		}
		for (option in MonitorOptionTest) {
			MonitorRegistry.register(option.op, option.monitor);
		}
	}

	// Parse a command-line argument, configuring and updating monitors. Return {true}
	// if the argument was matched and parsed successfully.
	def parse(arg: string) -> bool {
		if (!Strings.startsWith(arg, "--monitors=")) return false;
		var s = 11;
		var inArg = false;
		for (i = s; i < arg.length; i++) {
			// Allow commas between monitor arguments
			if (arg[i] == '{') inArg = true;
			if (arg[i] == '}') inArg = false;
			if (!inArg && arg[i] == ',') {
				addMonitor(arg, s, i);
				s = i + 1;
			}
		}
		if (s < arg.length) addMonitor(arg, s, arg.length);
		return true;
	}
	private def addMonitor(arg: string, start: int, end: int) {
		var name = Arrays.range(arg, start, end);
		var args: string;

		for (i < name.length) {
			if (name[i] == '{' && name[name.length - 1] == '}') {
				args = Arrays.range(name, i + 1, name.length - 1);
				name = Arrays.range(name, 0, i);
			}
		}
		var m = MonitorRegistry.lookupName(name);
		if (m != null) {
			if (args != null) {
				var msg = m.configure(args);
				if (msg != null) Trace.OUT.put2("%s: %s", name, msg).outln();
			}
			monitors.put(m);
		}
	}
	def insertMonitor(m: Monitor) {
		monitors.put(m);
	}
	// Get the monitors, if any, configured by the above.
	def getMonitors() -> Vector<Monitor> {
		return monitors;
	}
	def printHelp() {
		var out = Trace.OUT, H = out.putsln;
		H("");
		H("MONITOR OPTIONS");
		H("");
		H("A number of monitors are available for instrumentation and dynamic analysis");
		H("of WebAssembly bytecode. Multiple monitors may be specified together.");
		H("");
		H("   --monitors=<monitor>{<opts>}[,<monitor>{<opts>}]");
		H("");
		H("Each monitor comes with its own set of optional arguments and their modifiers.");
		H("");
		H("   <monitor>{<opt>=<modifier>[,<opt>=<modifier>]}");
		H("");

		for (option in MonitorOption) {
			out.puts("   ");
			out.puts(option.op);
			out.pad(' ', 16);
			out.puts(option.argsUsage);
			out.outln();
		}

		H("");
		H("Example usage:");
		H("");
		H("   --monitors=loops,coverage{code=instr}");
		out.outln();
	}
}
